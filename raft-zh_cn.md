# 寻找一种易于理解的一致性算法

## 摘要

Raft是一种为了管理复制日志的一致性算法。它提供了和Paxos算法相同的功能和性能，但是它的算法结构和Paxos不同，使得Raft算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft将一致性算法分解成了几个关键模块，例如选主、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。从一个用户研究的结果可以证明，对于学生而言，Raft算法比Paxos算法更加容易学习。Raft算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。

## 1 介绍

一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现故障也能够工作下去。正因为如此，一致性算法在构建可信赖的大规模软件系统中扮演着重要的角色。在过去的10年里，Paxos算法统治着一致性算法这一领域：绝大多数的实现都是基于Paxos或者受其影响。同时Paxos也成为了教学领域里讲解一致性问题时的示例。

但是不幸的是，尽管有很多工作都在尝试降低它的复杂性，但是Paxos算法依然十分难以理解。并且，Paxos自身的算法结构需要进行大幅的修改才能够应用到实际的系统中。这些都导致了工业界和学术界都对Paxos算法感到十分头疼。

和Paxos算法进行过努力之后，我们开始寻找一种新的一致性算法，可以为构建实际的系统和教学提供更好的基础。我们的做法是不寻常的，我们的首要目标是可理解性：我们是否可以在实际系统中定义一个一致性算法，并且能够比Paxos算法以一种更加容易的方式来学习。此外，我们希望该算法方便系统构建者的直觉的发展。不仅一个算法能够工作很重要，而且能够显而易见的知道为什么能工作也很重要。

Raft一致性算法就是这些工作的结果。在设计Raft算法的时候，我们使用一些特别的技巧来提升它的可理解性，包括算法分解（Raft主要被分成了选主，日志复制和安全三个模块）和减少状态机的状态（相对于Paxos，Raft减少了非确定性和服务器互相处于非一致性的方式）。一份针对在两所大学43个学生的研究表明Raft明显比Paxos算法更加容易理解。在这些学生同时学习了这两种算法之后，和Paxos比起来，其中33个学生能够回答有关于Raft的问题。

Raft算法在许多方面和现有的一致性算法都很相似（主要是Oki和Liskov的Viewstamped Replication），但是它也有一些独特的特性：

* **强领导者**：和其他一致性算法相比，Raft使用一种更强的领导能力形式。比如，日志项只从领导者发送给其他的服务器。这种方式简化了对复制日志的管理并且使得Raft算法更加易于理解。
* **领导选举**：Raft算法使用一个随机计时器来选举领导者。这种方式只在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。
* **关系调整**：<!-- 这儿需要仔细考察一下 -->

我们相信，Raft算法不论出于教学目的还是作为实践项目的基础都是要比Paxos或者其他一致性算法要优异的。它比其他算法更加简单，更见容易理解；它的算法描述足以实现一个现实的系统；它有好多开源的实现并且在很多公司里使用；它的安全性已经被证明；它的效率和其他算法比起来也不相上下。

接下来，这篇论文会介绍以下内容：复制状态机问题（第 2 节），讨论Paxos的优点和缺点（第 3 节），讨论我们为了理解能力而使用的方法（第 4 节），阐述Raft一致性算法（第 5-8 节），评价Raft算法（第 9 节），以及一些相关的工作（第 10 节）。

## 2 复制状态机

一致性算法是从复制状态机的背景下提出的。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。复制状态机在分布式系统中被用于解决很多容忍错误的问题。例如，大规模的系统中通常都有一个集群领导者，像GFS、HDFS和RAMCloud，十分典型的使用一个单独的复制状态机去管理领导选举和存储配置信息并且在领导人宕机的情况下也要存活下来。比如Chubby和ZooKeeper。

<!-- 图片1待补充 -->

复制状态机通常都是基于复制日志实现的，如图1。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。

保证复制日志相同就是一致性算法的工作了。在一台服务器上，一致性模块接收客户端发送来的指令然后增加到自己的日志中去。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都已相同的顺序包含相同的请求，尽管有些服务器会宕机。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。

实际系统中使用的一致性算法通常含有以下特性：

* 安全性保证（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确。
* 可用性：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含5个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。他们当有稳定的存储的时候可以从状态中恢复回来并重新加入集群。
* 不依赖时序来保证一致性：物理时钟错误或者极端的消息延迟在可能只有在最坏情况下才会导致可用性问题。
* 通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。

## 3 Paxos算法的问题

在过去的10年里，Leslie Lamport的Paxos算法几乎已经成为一致性的代名词：Paxos是在课程教学中最经常使用的算法，同时也是大多数一致性算法实现的起点。Paxos首先定义了一个能够达成单一决策一致的协议，比如单条的复制日志项。我们把这一子集叫做单决策Paxos。然后通过组合多个Paxos协议的实例来促进一系列决策的达成。Paxos保证安全性和活性，同时也支持集群成员关系的变更。Paxos的正确性已经被证明，在通常情况下也很高效。

不幸的是，Paxos有两个明显的缺点。第一个缺点是Paxos算法特别的难以理解。完整的解释是出了名的不透明；通过极大的努力之后，也只有少数人成功理解了这个算法。因此，有了几次用更简单的术语来解释Paxos的尝试。尽管这些解释都只关注了单决策的子集问题，但依然很具有挑战性。在2012年NSDI的会议中的一次调查显示，很少有人对Paxos算法感到满意，甚至在经验老道的研究者中也是如此。我们自己也尝试去理解Paxos；我们一直没能理解Paxos直到我们读了很多对Paxos的简化解释并且设计了我们自己的算法，这一过程花了近一年时间。

我们假设Paxos的不透明性来自它选择单决策问题作为它的基础。单决策Paxos是晦涩微妙的，它被划分成了两种没有简单直观解释和无法独立理解的情景。因此，这导致了很难建立起直观的感受为什么单决策Paxos算法能够工作。构成多决策Paxos增加了很多错综复杂的规则。我们相信，在多决策上达成一致性的问题（一份日志而不是单一的日志记录）能够被分解成其他的方式并且更加直接和明显。

Paxos算法的第二个问题就是它没有提供一个足够好的用来构建一个现实系统的基础。一个原因是还没有一种被广泛相互认同的多决策问题的算法。Lamport的描述基本上都是关于单决策Paxos的；他简要描述了实施多决策Paxos的方法，但是缺乏很多细节。当然也有很多具体化Paxos的尝试，但是他们都互相不一样，和Paxos的概述也不同。例如Chubby这样的系统实现了一个类似于Paxos的算法，但是大多数的细节并没有被公开。

而且，Paxos算法的结构也不是十分易于构建实践的系统；单决策分解也会产生其他的结果。例如，独立的选择一组日志项然后合并成一个序列化的日志并没有带来太多的好处，仅仅增加了不少复杂性。围绕着日志来设计一个系统是更加简单高效的；新日志项以严格限制的顺序增添到日志中去。另一个问题是，Paxos使用了一种对等的点对点的方式作为它的核心（尽管它最终提议了一种弱领导人的方法来优化性能）。在只有一个决策会被制定的简化世界中是很有意义的，但是很少有现实的系统使用这种方式。如果有一系列的决策需要被制定，首先选择一个领导人，然后让他去协调所有的决议，会更加简单快速。

因此，实际的系统中很少有和Paxos相似的实践。每一种实现都是从Paxos开始研究，然后发现很多实现上的难题，再然后开发了一种和Paxos明显不一样的结构。这样非常费时和容易出错的，并且理解Paxos的难度是的这个问题更加糟糕。Paxos算法在理论上被证明是正确可行的，但是现实的系统和Paxos差别是如此的大，以至于这些证明没有什么太大的价值。下面来自Chubby实现非常典型：

> 在Paxos算法描述和实现现实系统中间有者巨大的鸿沟。最终的系统建立在一种没有经过证明的算法之上。

由于以上问题，我们认为Paxos算法既没有提供一个良好的基础给实践的系统，也没有给教学很好的帮助。基于一致性问题在大规模软件系统中的重要性，我们决定看看我们是否可以设计一个拥有更好特性的替代Paxos的一致性算法。Raft算法就是这次实验的结果。



